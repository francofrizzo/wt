#!/bin/bash
set -eo pipefail

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/wt/repos"

# --- dependency check ---

_check_deps() {
  local missing=()
  for cmd in git gh jq perl; do
    command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
  done
  if [ ${#missing[@]} -gt 0 ]; then
    echo "Missing required dependencies: ${missing[*]}" >&2
    echo "Install them and try again." >&2
    exit 1
  fi
}

# --- safe config loader ---

_load_config() {
  local file="$1"
  local key value
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    # Match KEY="value" or KEY=value (only allowed keys)
    if [[ "$line" =~ ^(BARE|WORKTREES|REPO|WORKSPACE|SHARED|DEFAULT_BRANCH)=(.*) ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      # Strip surrounding quotes (single or double)
      if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi
      eval "$key=\"\$value\""
    fi
  done < "$file"
}

# --- config resolution ---

resolve_repo() {
  if [ -n "${WT_REPO:-}" ]; then
    local conf="$CONFIG_DIR/$WT_REPO.conf"
    if [ ! -f "$conf" ]; then
      echo "Unknown repo: $WT_REPO (no config at $conf)" >&2
      exit 1
    fi
    _load_config "$conf"
    return 0
  fi

  for conf in "$CONFIG_DIR"/*.conf; do
    [ -f "$conf" ] || continue
    (
      _load_config "$conf"
      case "$PWD" in
        "${BARE:-}"*|"${WORKTREES:-}"*) exit 0 ;;
      esac
      exit 1
    ) && { _load_config "$conf"; return 0; }
  done

  local configs=("$CONFIG_DIR"/*.conf)
  if [ ${#configs[@]} -eq 1 ] && [ -f "${configs[0]}" ]; then
    _load_config "${configs[0]}"
    return 0
  fi

  echo "Could not determine repo. Use --repo <name> or cd into a worktree." >&2
  echo "Configured repos:" >&2
  for conf in "$CONFIG_DIR"/*.conf; do
    [ -f "$conf" ] || continue
    echo "  $(basename "$conf" .conf)" >&2
  done
  exit 1
}

# --- workspace helpers (no-op when WORKSPACE is unset) ---

# VS Code workspace files use JSONC (trailing commas, comments).
# jq only accepts strict JSON, so we strip comments and trailing commas first.
# Note: comments in the workspace file will be lost after modification.
workspace_read() {
  perl -0777 -pe '
    s{/\*.*?\*/}{}gs;
    s{//[^\n]*}{}g;
    s/,(\s*[\]}])/$1/g;
  ' "$WORKSPACE"
}

workspace_add() {
  [ -n "${WORKSPACE:-}" ] && [ -f "$WORKSPACE" ] || return 0
  local wt_path="$1"
  workspace_read | jq --arg p "$wt_path" '.folders = [{"path": $p}] + .folders' > "$WORKSPACE.tmp" \
    && mv "$WORKSPACE.tmp" "$WORKSPACE"
}

workspace_remove() {
  [ -n "${WORKSPACE:-}" ] && [ -f "$WORKSPACE" ] || return 0
  local wt_path="$1"
  workspace_read | jq --arg p "$wt_path" '.folders = [.folders[] | select(.path != $p)]' > "$WORKSPACE.tmp" \
    && mv "$WORKSPACE.tmp" "$WORKSPACE"
}

# --- github helpers ---

gh_status() {
  local branch="$1" review="$2"
  local checks_json

  checks_json=$(gh api "repos/$REPO/commits/$branch/check-runs" --jq '.check_runs[] | .conclusion' 2>/dev/null || true)

  local ci=""
  if [ -z "$checks_json" ]; then
    ci="-"
  elif echo "$checks_json" | grep -q "failure"; then
    ci="\033[31mfail\033[0m"
  elif echo "$checks_json" | grep -q "null"; then
    ci="\033[33mrunning\033[0m"
  else
    ci="\033[32mpass\033[0m"
  fi

  local rv=""
  case "$review" in
    APPROVED)          rv="\033[32mapproved\033[0m" ;;
    CHANGES_REQUESTED) rv="\033[31mchanges\033[0m" ;;
    "")                rv="pending" ;;
    *)                 rv="$review" ;;
  esac

  echo -e "ci:${ci} review:${rv}"
}

# --- commands ---

cmd_list() {
  local open_prs merged_prs
  open_prs=$(gh pr list --repo "$REPO" --state open --json headRefName,number,reviewDecision 2>/dev/null || echo "[]")
  merged_prs=$(gh pr list --repo "$REPO" --state merged --limit 50 --json headRefName,number,mergedAt 2>/dev/null || echo "[]")

  local first=true
  while IFS= read -r line; do
    local wt_path branch_ref
    wt_path=$(echo "$line" | cut -d' ' -f1)
    branch_ref=$(echo "$line" | cut -d' ' -f2)

    [ "$wt_path" = "$BARE" ] && continue

    local branch="${branch_ref#refs/heads/}"
    local dir_name
    dir_name=$(basename "$wt_path")

    local last_commit
    last_commit=$(git -C "$wt_path" log -1 --format='%ar  %s' 2>/dev/null || echo "no commits")
    last_commit="${last_commit:0:72}"

    local created
    created=$(stat -f '%SB' -t '%Y-%m-%d' "$wt_path" 2>/dev/null || echo "?")

    local wt_porcelain local_line=""
    wt_porcelain=$(git -C "$wt_path" status --porcelain 2>/dev/null || true)
    if [ -n "$wt_porcelain" ]; then
      local n_changed n_untracked parts=""
      n_changed=$(echo "$wt_porcelain" | grep -cv '^??' || true)
      n_untracked=$(echo "$wt_porcelain" | grep -c '^??' || true)
      [ "$n_changed" -gt 0 ] && parts="${n_changed} changed"
      if [ "$n_untracked" -gt 0 ]; then
        [ -n "$parts" ] && parts="$parts, "
        parts="${parts}${n_untracked} untracked"
      fi
      local_line="$parts"
    fi

    local equal_default=""
    if [ "$branch" != "${DEFAULT_BRANCH:-main}" ]; then
      if git -C "$BARE" merge-base --is-ancestor "$branch" "origin/${DEFAULT_BRANCH:-main}" 2>/dev/null; then
        equal_default=true
      fi
    fi

    local gh_line="" name_color="1;33"
    if [ "$branch" = "${DEFAULT_BRANCH:-main}" ]; then
      name_color="1;34"
    fi

    local pr_number
    pr_number=$(echo "$open_prs" | jq -r --arg b "$branch" '.[] | select(.headRefName == $b) | .number' 2>/dev/null)

    if [ -n "$pr_number" ]; then
      local pr_review
      pr_review=$(echo "$open_prs" | jq -r --arg b "$branch" '.[] | select(.headRefName == $b) | .reviewDecision' 2>/dev/null)
      gh_line="PR #${pr_number}: $(gh_status "$branch" "$pr_review")"
    else
      local merged_number merged_at
      merged_number=$(echo "$merged_prs" | jq -r --arg b "$branch" '[.[] | select(.headRefName == $b)] | first | .number // empty' 2>/dev/null)
      if [ -n "$merged_number" ]; then
        merged_at=$(echo "$merged_prs" | jq -r --arg b "$branch" '[.[] | select(.headRefName == $b)] | first | .mergedAt // empty' 2>/dev/null)
        local merged_date="${merged_at%%T*}"
        gh_line="\033[32mmerged\033[0m PR #${merged_number} ($merged_date)"
        name_color="2;37"
      fi
    fi

    if [ -n "$equal_default" ] && [ "$name_color" = "1;33" ]; then
      name_color="2;37"
    fi

    if [ "$first" = true ]; then
      first=false
    else
      echo ""
    fi

    echo -e "\033[${name_color}m$dir_name\033[0m  ($branch)  created $created"
    echo "  commit: $last_commit"
    if [ -n "$local_line" ]; then
      echo -e "  local: \033[33m$local_line\033[0m"
    fi
    if [ -n "$equal_default" ]; then
      echo -e "  \033[2;37m= ${DEFAULT_BRANCH:-main} (no unique commits)\033[0m"
    fi
    if [ -n "$gh_line" ]; then
      echo -e "  $gh_line"
    fi
  done < <(git -C "$BARE" worktree list --porcelain | awk '/^worktree /{wt=$2} /^branch /{print wt, $2}')
}

_symlink_shared() {
  local src="$1" dest="$2"
  for entry in "$src"/* "$src"/.*; do
    case "$(basename "$entry")" in .|..) continue ;; esac
    [ -e "$entry" ] || continue
    if [ -d "$entry" ]; then
      mkdir -p "$dest/$(basename "$entry")"
      _symlink_shared "$entry" "$dest/$(basename "$entry")"
    else
      ln -sf "$entry" "$dest/$(basename "$entry")"
    fi
  done
}

cmd_fork() {
  local no_symlink=false
  local positional=()
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-symlink) no_symlink=true; shift ;;
      *) positional+=("$1"); shift ;;
    esac
  done

  local new_branch="${positional[0]:-}"
  if [ -z "$new_branch" ]; then
    echo "Usage: wt fork <new-branch> [--no-symlink]" >&2
    exit 1
  fi

  local current_wt current_branch relative_path
  current_wt=$(git rev-parse --show-toplevel 2>/dev/null) \
    || { echo "Error: not inside a worktree" >&2; exit 1; }
  current_branch=$(git -C "$current_wt" branch --show-current)
  relative_path="${PWD#"$current_wt"}"

  local new_dir="${new_branch//\//-}"

  if [ -d "$WORKTREES/$new_dir" ]; then
    echo "Worktree already exists: $WORKTREES/$new_dir" >&2
    echo "$WORKTREES/$new_dir$relative_path"
    return 0
  fi

  local has_changes=false
  if ! git -C "$current_wt" diff --quiet 2>/dev/null || \
     ! git -C "$current_wt" diff --cached --quiet 2>/dev/null || \
     [ -n "$(git -C "$current_wt" ls-files --others --exclude-standard 2>/dev/null)" ]; then
    has_changes=true
    echo "Stashing changes from $current_branch..." >&2
    git -C "$current_wt" stash push --include-untracked -m "wt fork: moving to $new_branch" >&2
  fi

  git -C "$BARE" worktree add --no-track -b "$new_branch" "$WORKTREES/$new_dir" "$current_branch" >&2

  if [ -d "${SHARED:-}" ]; then
    if [ "$no_symlink" = true ]; then
      cp -r "$SHARED"/. "$WORKTREES/$new_dir"/
    else
      _symlink_shared "$SHARED" "$WORKTREES/$new_dir"
    fi
  fi

  if [ "$has_changes" = true ]; then
    echo "Applying changes in $new_branch..." >&2
    if ! git -C "$WORKTREES/$new_dir" stash pop >&2; then
      echo "Warning: stash applied with conflicts — resolve them in the new worktree" >&2
    fi
  fi

  workspace_add "$WORKTREES/$new_dir"
  echo "Forked: $current_branch → $new_branch" >&2
  echo "$WORKTREES/$new_dir$relative_path"
}

cmd_add() {
  local no_symlink=false
  local positional=()
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-symlink) no_symlink=true; shift ;;
      *) positional+=("$1"); shift ;;
    esac
  done

  local branch="${positional[0]:-}"
  local base="${positional[1]:-origin/${DEFAULT_BRANCH:-main}}"
  local dir="${branch//\//-}"

  if [ -z "$branch" ]; then
    echo "Usage: wt add <branch> [base] [--no-symlink]" >&2
    exit 1
  fi

  if [ -d "$WORKTREES/$dir" ]; then
    echo "Worktree already exists: $WORKTREES/$dir" >&2
    echo "$WORKTREES/$dir"
    return 0
  fi

  echo "Fetching origin..." >&2
  git -C "$BARE" fetch origin >&2

  if git -C "$BARE" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null || \
     git -C "$BARE" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
    git -C "$BARE" worktree add "$WORKTREES/$dir" "$branch" >&2
  else
    git -C "$BARE" worktree add --no-track -b "$branch" "$WORKTREES/$dir" "$base" >&2
  fi

  if [ -d "${SHARED:-}" ]; then
    if [ "$no_symlink" = true ]; then
      cp -r "$SHARED"/. "$WORKTREES/$dir"/
    else
      _symlink_shared "$SHARED" "$WORKTREES/$dir"
    fi
  fi

  workspace_add "$WORKTREES/$dir"
  echo "Ready: $WORKTREES/$dir" >&2
  echo "$WORKTREES/$dir"
}

cmd_rm() {
  local force=""
  if [ "${1:-}" = "--force" ] || [ "${1:-}" = "-f" ]; then
    force="--force"
    shift
  fi
  local branch="${1:-}"
  if [ -z "$branch" ]; then
    echo "Usage: wt rm [-f|--force] <branch>" >&2
    exit 1
  fi
  local dir="${branch//\//-}"

  # Look up the actual branch name before removing the worktree
  local actual_branch=""
  actual_branch=$(git -C "$BARE" worktree list --porcelain \
    | awk -v wt="$WORKTREES/$dir" '/^worktree /{w=$2} /^branch /{if(w==wt) print $2}' \
    | sed 's#refs/heads/##')

  if [ -n "$force" ]; then
    git -C "$BARE" worktree remove --force "$WORKTREES/$dir" >&2
  else
    git -C "$BARE" worktree remove "$WORKTREES/$dir" >&2
  fi
  workspace_remove "$WORKTREES/$dir"

  # Clean up the local branch (safe delete only — fails if not merged)
  if [ -n "$actual_branch" ] && [ "$actual_branch" != "${DEFAULT_BRANCH:-main}" ]; then
    git -C "$BARE" branch -d "$actual_branch" 2>/dev/null || true
  fi

  echo "Removed: $WORKTREES/$dir" >&2
}

cmd_cd() {
  local branch="${1:-}"
  if [ -z "$branch" ]; then
    echo "Usage: wt cd <branch>" >&2
    exit 1
  fi
  if [ "$branch" = "${DEFAULT_BRANCH:-main}" ]; then
    echo "$BARE"
    return
  fi
  local dir="${branch//\//-}"
  if [ ! -d "$WORKTREES/$dir" ]; then
    echo "Worktree not found: $WORKTREES/$dir" >&2
    exit 1
  fi
  echo "$WORKTREES/$dir"
}

cmd_prune() {
  local dry_run=false
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run|-n) dry_run=true; shift ;;
      *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
  done

  local merged_prs
  merged_prs=$(gh pr list --repo "$REPO" --state merged --limit 50 --json headRefName,number 2>/dev/null || echo "[]")

  echo "Fetching origin..." >&2
  git -C "$BARE" fetch origin >&2

  local to_remove=()
  local dirty_skipped=()
  while IFS= read -r line; do
    local wt_path branch_ref
    wt_path=$(echo "$line" | cut -d' ' -f1)
    branch_ref=$(echo "$line" | cut -d' ' -f2)

    [ "$wt_path" = "$BARE" ] && continue

    local branch="${branch_ref#refs/heads/}"
    [ "$branch" = "${DEFAULT_BRANCH:-main}" ] && continue

    local reason=""
    local pr_number
    pr_number=$(echo "$merged_prs" | jq -r --arg b "$branch" '[.[] | select(.headRefName == $b)] | first | .number // empty' 2>/dev/null)

    if [ -n "$pr_number" ]; then
      reason="merged PR #$pr_number"
    elif git -C "$BARE" merge-base --is-ancestor "$branch" "origin/${DEFAULT_BRANCH:-main}" 2>/dev/null; then
      local wt_porcelain
      wt_porcelain=$(git -C "$wt_path" status --porcelain 2>/dev/null || true)
      if [ -n "$wt_porcelain" ]; then
        dirty_skipped+=("$wt_path|$branch")
        continue
      fi
      reason="= ${DEFAULT_BRANCH:-main}"
    fi

    if [ -n "$reason" ]; then
      to_remove+=("$wt_path|$branch|$reason")
    fi
  done < <(git -C "$BARE" worktree list --porcelain | awk '/^worktree /{wt=$2} /^branch /{print wt, $2}')

  if [ ${#to_remove[@]} -eq 0 ] && [ ${#dirty_skipped[@]} -eq 0 ]; then
    echo "No worktrees to clean up."
    return 0
  fi

  if [ ${#dirty_skipped[@]} -gt 0 ]; then
    echo "Skipping ${#dirty_skipped[@]} worktree(s) with local changes (= ${DEFAULT_BRANCH:-main} but dirty):"
    for entry in "${dirty_skipped[@]}"; do
      local wt_path branch
      IFS='|' read -r wt_path branch <<< "$entry"
      echo -e "  \033[33m$(basename "$wt_path")\033[0m  ($branch)"
    done
    echo ""
  fi

  if [ ${#to_remove[@]} -eq 0 ]; then
    echo "No clean worktrees to remove."
    return 0
  fi

  if [ "$dry_run" = true ]; then
    echo "Would remove ${#to_remove[@]} worktree(s):"
    for entry in "${to_remove[@]}"; do
      local wt_path branch reason
      IFS='|' read -r wt_path branch reason <<< "$entry"
      echo -e "  \033[2;37m$(basename "$wt_path")\033[0m  ($branch)  $reason"
    done
    return 0
  fi

  echo "Will remove ${#to_remove[@]} worktree(s):"
  for entry in "${to_remove[@]}"; do
    local wt_path branch reason
    IFS='|' read -r wt_path branch reason <<< "$entry"
    echo -e "  \033[2;37m$(basename "$wt_path")\033[0m  ($branch)  $reason"
  done

  echo ""
  printf "Proceed? [y/N] "
  read -r answer
  if [[ "$answer" != [yY] ]]; then
    echo "Aborted."
    return 0
  fi

  for entry in "${to_remove[@]}"; do
    local wt_path branch reason
    IFS='|' read -r wt_path branch reason <<< "$entry"
    git -C "$BARE" worktree remove "$wt_path" 2>&1 && workspace_remove "$wt_path"
    # Clean up the local branch (safe delete only)
    if [ "$branch" != "${DEFAULT_BRANCH:-main}" ]; then
      git -C "$BARE" branch -d "$branch" 2>/dev/null || true
    fi
    echo "Removed: $(basename "$wt_path")"
  done
}

cmd_init() {
  local arg="${1:-}"
  local name="" bare="" worktrees="" repo="" workspace="" shared="" default_branch=""

  # --- Mode 1: wt init <url> — clone from URL ---
  if [[ "$arg" == http* || "$arg" == git@* || "$arg" == file://* ]]; then
    local url="$arg"; shift
    name=$(echo "$url" | sed -E 's#.*/##; s/\.git$//')

    while [ $# -gt 0 ]; do
      case "$1" in
        --name)           name="$2"; shift 2 ;;
        --worktrees)      worktrees="$2"; shift 2 ;;
        --workspace)      workspace="$2"; shift 2 ;;
        --shared)         shared="$2"; shift 2 ;;
        --default-branch) default_branch="$2"; shift 2 ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
      esac
    done

    local target="${worktrees:-$PWD}/${name}.git"
    if [ -n "$worktrees" ]; then
      target="$(dirname "$worktrees")/${name}.git"
    fi

    echo "Cloning $url (bare) into $target ..." >&2
    git clone --bare "$url" "$target" >&2

    bare="$target"

    git -C "$bare" config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*' >&2
    git -C "$bare" fetch origin >&2

  # --- Mode 2: wt init (no args) — detect from cwd ---
  elif [ -z "$arg" ] || [[ "$arg" == --* ]]; then
    # $arg is already $1 (no shift happened), so just loop over $@
    while [ $# -gt 0 ]; do
      case "$1" in
        --bare)           bare="$2"; shift 2 ;;
        --worktrees)      worktrees="$2"; shift 2 ;;
        --repo)           repo="$2"; shift 2 ;;
        --workspace)      workspace="$2"; shift 2 ;;
        --shared)         shared="$2"; shift 2 ;;
        --default-branch) default_branch="$2"; shift 2 ;;
        --name)           name="$2"; shift 2 ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
      esac
    done

    if [ -z "$bare" ]; then
      local git_dir
      git_dir=$(git rev-parse --git-common-dir 2>/dev/null || true)

      if [ -z "$git_dir" ] || [ "$git_dir" = ".git" ]; then
        echo "Not inside a git worktree and no --bare specified." >&2
        echo "" >&2
        echo "Usage:" >&2
        echo "  wt init <github-url>             Clone and configure" >&2
        echo "  wt init                           Auto-detect from cwd (inside a worktree)" >&2
        echo "  wt init <name> --bare <path>      Explicit configuration" >&2
        exit 1
      fi

      bare="$(cd "$git_dir" && pwd)"
    fi

  # --- Mode 3: wt init <name> [--flags] — explicit ---
  else
    name="$arg"; shift

    while [ $# -gt 0 ]; do
      case "$1" in
        --bare)           bare="$2"; shift 2 ;;
        --worktrees)      worktrees="$2"; shift 2 ;;
        --repo)           repo="$2"; shift 2 ;;
        --workspace)      workspace="$2"; shift 2 ;;
        --shared)         shared="$2"; shift 2 ;;
        --default-branch) default_branch="$2"; shift 2 ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
      esac
    done

    if [ -z "$bare" ]; then
      echo "Error: --bare <path> is required when using wt init <name>" >&2
      exit 1
    fi
  fi

  # --- Resolve paths and defaults ---

  bare="$(cd "$(dirname "$bare")" && pwd)/$(basename "$bare")"

  if [ -z "$name" ]; then
    name=$(basename "$bare" .git)
    name="${name%.bare}"
  fi

  if [ -z "$worktrees" ]; then
    local parent
    parent="$(dirname "$bare")"
    worktrees="$parent/${name}-worktrees"
  fi
  # shellcheck disable=SC2269
  worktrees="$(cd "$(dirname "$worktrees")" 2>/dev/null && pwd)/$(basename "$worktrees")" 2>/dev/null || worktrees="$worktrees"

  if [ -z "$repo" ]; then
    local remote_url
    remote_url=$(git -C "$bare" remote get-url origin 2>/dev/null || true)
    if [ -n "$remote_url" ]; then
      repo=$(echo "$remote_url" | sed -E 's#.*github\.com[:/]##; s/\.git$//')
      echo "Detected GitHub repo: $repo" >&2
    fi
  fi

  if [ -z "$default_branch" ]; then
    default_branch=$(git -C "$bare" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's#refs/remotes/origin/##' || true)
  fi

  mkdir -p "$worktrees"

  # --- Write config ---

  mkdir -p "$CONFIG_DIR"
  local conf="$CONFIG_DIR/$name.conf"

  {
    echo "BARE=\"$bare\""
    echo "WORKTREES=\"$worktrees\""
    [ -n "$repo" ] && echo "REPO=\"$repo\""
    [ -n "$workspace" ] && echo "WORKSPACE=\"$workspace\""
    [ -n "$shared" ] && echo "SHARED=\"$shared\""
    [ -n "$default_branch" ] && echo "DEFAULT_BRANCH=\"$default_branch\""
  } > "$conf"

  echo "" >&2
  echo "Configured $name:" >&2
  cat "$conf" >&2
  echo "" >&2
  echo "Ready! Run 'wt <branch>' to create your first worktree." >&2
}

cmd_repos() {
  for conf in "$CONFIG_DIR"/*.conf; do
    [ -f "$conf" ] || continue
    local name
    name=$(basename "$conf" .conf)
    (
      _load_config "$conf"
      echo -e "\033[1;33m$name\033[0m"
      echo "  bare: ${BARE:-}"
      echo "  worktrees: ${WORKTREES:-}"
      [ -n "${REPO:-}" ] && echo "  repo: $REPO"
    )
  done
}

# --- completions (used by _wt) ---

cmd_completions() {
  case "${1:-}" in
    branches)
      git -C "$BARE" for-each-ref --format='%(refname:short)' refs/heads refs/remotes/origin 2>/dev/null \
        | sed 's|^origin/||' | sort -u
      ;;
    worktrees)
      git -C "$BARE" worktree list --porcelain 2>/dev/null \
        | sed -n 's/^branch refs\/heads\///p'
      ;;
    repos)
      for conf in "$CONFIG_DIR"/*.conf; do
        [ -f "$conf" ] || continue
        basename "$conf" .conf
      done
      ;;
  esac
}

cmd_help() {
  echo "wt - Git worktree manager with GitHub integration"
  echo ""
  echo "Usage:"
  echo "  wt <branch> [base]               Create worktree (shorthand for 'wt add')"
  echo "  wt add|new <branch> [base]       Create worktree from base ref"
  echo "      --no-symlink                  Copy shared files instead of symlinking"
  echo "  wt fork <branch>                 Fork current worktree into a new branch"
  echo "      --no-symlink                  Copy shared files instead of symlinking"
  echo "  wt cd <branch>                   Jump to an existing worktree"
  echo "  wt list|ls                       List all worktrees with PR/CI status"
  echo "  wt rm|remove [-f] <branch>       Remove a worktree (-f/--force to force)"
  echo "  wt prune|clean                   Remove all worktrees with merged PRs"
  echo "      --dry-run|-n                  Show what would be removed without deleting"
  echo "  wt repos                         List configured repositories"
  echo "  wt init <url>                    Clone a repo and configure it"
  echo "  wt init                          Auto-detect repo from current directory"
  echo "  wt init <name> --bare            Explicit configuration"
  echo ""
  echo "Options:"
  echo "  --repo <name>           Use a specific configured repo"
  echo ""
  echo "Examples:"
  echo "  wt init https://github.com/org/repo   Clone and set up"
  echo "  wt init                                Detect from cwd"
  echo "  wt init myproject --bare ~/code/p.git  Explicit bare path"
  echo "  wt my-feature                          Create branch off default"
  echo "  wt cd my-feature                       Jump to existing worktree"
  echo "  wt list                                Show worktrees with CI/review"
  echo "  wt prune                               Clean up merged worktrees"
  echo "  wt prune --dry-run                     Preview what would be pruned"
}

# --- main ---

main() {
  # Parse global flags
  if [[ "${1:-}" == "--repo" ]]; then
    WT_REPO="${2:-}"
    shift 2
  fi

  case "${1:-}" in
    ""|-h|--help)
      cmd_help
      exit 0
      ;;
    init)
      _check_deps
      shift
      cmd_init "$@"
      exit 0
      ;;
    repos)
      _check_deps
      cmd_repos
      exit 0
      ;;
    __complete)
      resolve_repo
      cmd_completions "$2"
      exit 0
      ;;
    list|ls|-l)
      _check_deps
      resolve_repo
      cmd_list
      ;;
    rm|remove|-r)
      _check_deps
      resolve_repo
      shift
      cmd_rm "$@"
      ;;
    prune|clean)
      _check_deps
      resolve_repo
      shift
      cmd_prune "$@"
      ;;
    cd)
      resolve_repo
      shift
      cmd_cd "$@"
      ;;
    add|new)
      _check_deps
      resolve_repo
      shift
      cmd_add "$@"
      ;;
    fork)
      _check_deps
      resolve_repo
      shift
      cmd_fork "$@"
      ;;
    *)
      _check_deps
      resolve_repo
      cmd_add "$@"
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
